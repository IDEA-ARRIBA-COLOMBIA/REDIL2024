import {
  EdgeProgram,
  NodeProgram,
  _callSuper,
  _classCallCheck,
  _createClass,
  _inherits,
  floatColor,
  require_is_graph
} from "./chunk-6W5EQMIG.js";
import {
  require_events
} from "./chunk-3RSY7R4N.js";
import {
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/sigma/rendering/dist/sigma-rendering.esm.js
var SHADER_SOURCE$5 = (
  /*glsl*/
  "\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float radius = 0.5;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = radius - length(m);\n\n  // No antialiasing for picking mode:\n  #ifdef PICKING_MODE\n  if (dist > v_border)\n    gl_FragColor = v_color;\n  else\n    gl_FragColor = transparent;\n\n  #else\n  float t = 0.0;\n  if (dist > v_border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / v_border;\n\n  gl_FragColor = mix(transparent, v_color, t);\n  #endif\n}\n"
);
var FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$5;
var SHADER_SOURCE$4 = (
  /*glsl*/
  "\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\nattribute float a_size;\n\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\n\n  v_border = (0.5 / a_size) * u_sizeRatio;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n"
);
var VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$4;
var _WebGLRenderingContex$2 = WebGLRenderingContext;
var UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE;
var FLOAT$2 = _WebGLRenderingContex$2.FLOAT;
var UNIFORMS$2 = ["u_sizeRatio", "u_pixelRatio", "u_matrix"];
var NodePointProgram = function(_NodeProgram) {
  _inherits(NodePointProgram2, _NodeProgram);
  function NodePointProgram2() {
    _classCallCheck(this, NodePointProgram2);
    return _callSuper(this, NodePointProgram2, arguments);
  }
  _createClass(NodePointProgram2, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 1,
        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,
        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,
        METHOD: WebGLRenderingContext.POINTS,
        UNIFORMS: UNIFORMS$2,
        ATTRIBUTES: [{
          name: "a_position",
          size: 2,
          type: FLOAT$2
        }, {
          name: "a_size",
          size: 1,
          type: FLOAT$2
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE$2,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE$2,
          normalized: true
        }]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(nodeIndex, startIndex, data) {
      var array = this.array;
      array[startIndex++] = data.x;
      array[startIndex++] = data.y;
      array[startIndex++] = data.size;
      array[startIndex++] = floatColor(data.color);
      array[startIndex++] = nodeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(_ref, _ref2) {
      var sizeRatio = _ref.sizeRatio, pixelRatio = _ref.pixelRatio, matrix = _ref.matrix;
      var gl = _ref2.gl, uniformLocations = _ref2.uniformLocations;
      var u_sizeRatio = uniformLocations.u_sizeRatio, u_pixelRatio = uniformLocations.u_pixelRatio, u_matrix = uniformLocations.u_matrix;
      gl.uniform1f(u_pixelRatio, pixelRatio);
      gl.uniform1f(u_sizeRatio, sizeRatio);
      gl.uniformMatrix3fv(u_matrix, false, matrix);
    }
  }]);
  return NodePointProgram2;
}(NodeProgram);
var SHADER_SOURCE$3 = (
  /*glsl*/
  "\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n"
);
var FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$3;
var SHADER_SOURCE$2 = (
  /*glsl*/
  "\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\n\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  // Scale from [[-1 1] [-1 1]] to the container:\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n"
);
var VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$2;
var _WebGLRenderingContex$1 = WebGLRenderingContext;
var UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE;
var FLOAT$1 = _WebGLRenderingContex$1.FLOAT;
var UNIFORMS$1 = ["u_matrix"];
var EdgeLineProgram = function(_EdgeProgram) {
  _inherits(EdgeLineProgram2, _EdgeProgram);
  function EdgeLineProgram2() {
    _classCallCheck(this, EdgeLineProgram2);
    return _callSuper(this, EdgeLineProgram2, arguments);
  }
  _createClass(EdgeLineProgram2, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 2,
        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,
        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,
        METHOD: WebGLRenderingContext.LINES,
        UNIFORMS: UNIFORMS$1,
        ATTRIBUTES: [{
          name: "a_position",
          size: 2,
          type: FLOAT$1
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE$1,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE$1,
          normalized: true
        }]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
      var array = this.array;
      var x1 = sourceData.x;
      var y1 = sourceData.y;
      var x2 = targetData.x;
      var y2 = targetData.y;
      var color = floatColor(data.color);
      array[startIndex++] = x1;
      array[startIndex++] = y1;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;
      array[startIndex++] = x2;
      array[startIndex++] = y2;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(params, _ref) {
      var gl = _ref.gl, uniformLocations = _ref.uniformLocations;
      var u_matrix = uniformLocations.u_matrix;
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
    }
  }]);
  return EdgeLineProgram2;
}(EdgeProgram);
var SHADER_SOURCE$1 = (
  /*glsl*/
  "\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n"
);
var FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$1;
var SHADER_SOURCE = (
  /*glsl*/
  "\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  // The only different here with edge.vert.glsl is that we need to handle null\n  // input normal vector. Apart from that, you can read edge.vert.glsl more info\n  // on how it works:\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n  if (normalLength <= 0.0) unitNormal = normal;\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n"
);
var VERTEX_SHADER_SOURCE = SHADER_SOURCE;
var _WebGLRenderingContex = WebGLRenderingContext;
var UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE;
var FLOAT = _WebGLRenderingContex.FLOAT;
var UNIFORMS = ["u_matrix", "u_sizeRatio", "u_correctionRatio", "u_minEdgeThickness"];
var EdgeTriangleProgram = function(_EdgeProgram) {
  _inherits(EdgeTriangleProgram2, _EdgeProgram);
  function EdgeTriangleProgram2() {
    _classCallCheck(this, EdgeTriangleProgram2);
    return _callSuper(this, EdgeTriangleProgram2, arguments);
  }
  _createClass(EdgeTriangleProgram2, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 3,
        VERTEX_SHADER_SOURCE,
        FRAGMENT_SHADER_SOURCE,
        METHOD: WebGLRenderingContext.TRIANGLES,
        UNIFORMS,
        ATTRIBUTES: [{
          name: "a_positionStart",
          size: 2,
          type: FLOAT
        }, {
          name: "a_positionEnd",
          size: 2,
          type: FLOAT
        }, {
          name: "a_normal",
          size: 2,
          type: FLOAT
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE,
          normalized: true
        }],
        CONSTANT_ATTRIBUTES: [
          // If 0, then position will be a_positionStart
          // If 1, then position will be a_positionEnd
          {
            name: "a_positionCoef",
            size: 1,
            type: FLOAT
          },
          {
            name: "a_normalCoef",
            size: 1,
            type: FLOAT
          }
        ],
        CONSTANT_DATA: [[0, 1], [0, -1], [1, 0]]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
      var thickness = data.size || 1;
      var x1 = sourceData.x;
      var y1 = sourceData.y;
      var x2 = targetData.x;
      var y2 = targetData.y;
      var color = floatColor(data.color);
      var dx = x2 - x1;
      var dy = y2 - y1;
      var len = dx * dx + dy * dy;
      var n1 = 0;
      var n2 = 0;
      if (len) {
        len = 1 / Math.sqrt(len);
        n1 = -dy * len * thickness;
        n2 = dx * len * thickness;
      }
      var array = this.array;
      array[startIndex++] = x1;
      array[startIndex++] = y1;
      array[startIndex++] = x2;
      array[startIndex++] = y2;
      array[startIndex++] = n1;
      array[startIndex++] = n2;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(params, _ref) {
      var gl = _ref.gl, uniformLocations = _ref.uniformLocations;
      var u_matrix = uniformLocations.u_matrix, u_sizeRatio = uniformLocations.u_sizeRatio, u_correctionRatio = uniformLocations.u_correctionRatio, u_minEdgeThickness = uniformLocations.u_minEdgeThickness;
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
      gl.uniform1f(u_sizeRatio, params.sizeRatio);
      gl.uniform1f(u_correctionRatio, params.correctionRatio);
      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
    }
  }]);
  return EdgeTriangleProgram2;
}(EdgeProgram);

// node_modules/sigma/utils/dist/sigma-utils.esm.js
var import_is_graph = __toESM(require_is_graph());

// node_modules/@sigma/node-image/dist/sigma-node-image.esm.js
var import_events = __toESM(require_events());
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function toPrimitive(t, r) {
  if ("object" != typeof t || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t;
  })();
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _callSuper2(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function getFragmentShader(_ref) {
  var texturesCount = _ref.texturesCount;
  var SHADER = (
    /*glsl*/
    "\nprecision highp float;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying vec4 v_texture;\nvarying float v_textureIndex;\n\nuniform sampler2D u_atlas[".concat(texturesCount, "];\nuniform float u_correctionRatio;\nuniform float u_cameraAngle;\nuniform float u_percentagePadding;\nuniform bool u_colorizeImages;\nuniform bool u_keepWithinCircle;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nconst float radius = 0.5;\n\nvoid main(void) {\n  float border = 2.0 * u_correctionRatio;\n  float dist = length(v_diffVector);\n  vec4 color = gl_FragColor;\n\n  float c = cos(-u_cameraAngle);\n  float s = sin(-u_cameraAngle);\n  vec2 diffVector = mat2(c, s, -s, c) * (v_diffVector);\n\n  // No antialiasing for picking mode:\n  #ifdef PICKING_MODE\n  border = 0.0;\n  color = v_color;\n\n  #else\n  // First case: No image to display\n  if (v_texture.w <= 0.0) {\n    if (!u_colorizeImages) {\n      color = v_color;\n    }\n  }\n\n  // Second case: Image loaded into the texture\n  else {\n    float paddingRatio = 1.0 + 2.0 * u_percentagePadding;\n    float coef = u_keepWithinCircle ? 1.0 : ").concat(Math.SQRT2, ";\n    vec2 coordinateInTexture = diffVector * vec2(paddingRatio, -paddingRatio) / v_radius / 2.0 * coef + vec2(0.5, 0.5);\n    int index = int(v_textureIndex + 0.5); // +0.5 avoid rounding errors\n\n    bool noTextureFound = false;\n    vec4 texel;\n\n    ").concat(_toConsumableArray(new Array(texturesCount)).map(function(_, i) {
      return "if (index == ".concat(i, ") texel = texture2D(u_atlas[").concat(i, "], (v_texture.xy + coordinateInTexture * v_texture.zw), -1.0);");
    }).join("\n    else ") + "else {\n      texel = texture2D(u_atlas[0], (v_texture.xy + coordinateInTexture * v_texture.zw), -1.0);\n      noTextureFound = true;\n    }", '\n\n    if (noTextureFound) {\n      color = v_color;\n    } else {\n      // Colorize all visible image pixels:\n      if (u_colorizeImages) {\n        color = mix(gl_FragColor, v_color, texel.a);\n      }\n\n      // Colorize background pixels, keep image pixel colors:\n      else {\n        color = vec4(mix(v_color, texel, texel.a).rgb, max(texel.a, v_color.a));\n      }\n\n      // Erase pixels "in the padding":\n      if (abs(diffVector.x) > v_radius / paddingRatio || abs(diffVector.y) > v_radius / paddingRatio) {\n        color = u_colorizeImages ? gl_FragColor : v_color;\n      }\n    }\n  }\n  #endif\n\n  // Crop in a circle when u_keepWithinCircle is truthy:\n  if (u_keepWithinCircle) {\n    if (dist < v_radius - border) {\n      gl_FragColor = color;\n    } else if (dist < v_radius) {\n      gl_FragColor = mix(transparent, color, (v_radius - dist) / border);\n    }\n  }\n\n  // Crop in a square else:\n  else {\n    float squareHalfSize = v_radius * ').concat(Math.SQRT1_2 * Math.cos(Math.PI / 12), ";\n    if (abs(diffVector.x) > squareHalfSize || abs(diffVector.y) > squareHalfSize) {\n      gl_FragColor = transparent;\n    } else {\n      gl_FragColor = color;\n    }\n  }\n}\n")
  );
  return SHADER;
}
var VERTEX_SHADER_SOURCE2 = (
  /*glsl*/
  "\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\nattribute float a_size;\nattribute float a_angle;\nattribute vec4 a_texture;\nattribute float a_textureIndex;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying vec4 v_texture;\nvarying float v_textureIndex;\n\nconst float bias = 255.0 / 254.0;\nconst float marginRatio = 1.05;\n\nvoid main() {\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\n  vec2 position = a_position + diffVector * marginRatio;\n  gl_Position = vec4(\n    (u_matrix * vec3(position, 1)).xy,\n    0,\n    1\n  );\n\n  v_diffVector = diffVector;\n  v_radius = size / 2.0 / marginRatio;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n\n  // Pass the texture coordinates:\n  v_textureIndex = a_textureIndex;\n  v_texture = a_texture;\n  #endif\n\n  v_color.a *= bias;\n}\n"
);
var VERTEX_SHADER_SOURCE$12 = VERTEX_SHADER_SOURCE2;
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return e;
  };
  var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
    t2[e2] = r2.value;
  }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
  function define(t2, e2, r2) {
    return Object.defineProperty(t2, e2, {
      value: r2,
      enumerable: true,
      configurable: true,
      writable: true
    }), t2[e2];
  }
  try {
    define({}, "");
  } catch (t2) {
    define = function(t3, e2, r2) {
      return t3[e2] = r2;
    };
  }
  function wrap(t2, e2, r2, n2) {
    var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
    return o(a2, "_invoke", {
      value: makeInvokeMethod(t2, r2, c2)
    }), a2;
  }
  function tryCatch(t2, e2, r2) {
    try {
      return {
        type: "normal",
        arg: t2.call(e2, r2)
      };
    } catch (t3) {
      return {
        type: "throw",
        arg: t3
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p = {};
  define(p, a, function() {
    return this;
  });
  var d = Object.getPrototypeOf, v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t2) {
    ["next", "throw", "return"].forEach(function(e2) {
      define(t2, e2, function(t3) {
        return this._invoke(e2, t3);
      });
    });
  }
  function AsyncIterator(t2, e2) {
    function invoke(r3, o2, i2, a2) {
      var c2 = tryCatch(t2[r3], t2, o2);
      if ("throw" !== c2.type) {
        var u2 = c2.arg, h2 = u2.value;
        return h2 && "object" == typeof h2 && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
          invoke("next", t3, i2, a2);
        }, function(t3) {
          invoke("throw", t3, i2, a2);
        }) : e2.resolve(h2).then(function(t3) {
          u2.value = t3, i2(u2);
        }, function(t3) {
          return invoke("throw", t3, i2, a2);
        });
      }
      a2(c2.arg);
    }
    var r2;
    o(this, "_invoke", {
      value: function(t3, n2) {
        function callInvokeWithMethodAndArg() {
          return new e2(function(e3, r3) {
            invoke(t3, n2, e3, r3);
          });
        }
        return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e2, r2, n2) {
    var o2 = h;
    return function(i2, a2) {
      if (o2 === f)
        throw new Error("Generator is already running");
      if (o2 === s) {
        if ("throw" === i2)
          throw a2;
        return {
          value: t,
          done: true
        };
      }
      for (n2.method = i2, n2.arg = a2; ; ) {
        var c2 = n2.delegate;
        if (c2) {
          var u2 = maybeInvokeDelegate(c2, n2);
          if (u2) {
            if (u2 === y)
              continue;
            return u2;
          }
        }
        if ("next" === n2.method)
          n2.sent = n2._sent = n2.arg;
        else if ("throw" === n2.method) {
          if (o2 === h)
            throw o2 = s, n2.arg;
          n2.dispatchException(n2.arg);
        } else
          "return" === n2.method && n2.abrupt("return", n2.arg);
        o2 = f;
        var p2 = tryCatch(e2, r2, n2);
        if ("normal" === p2.type) {
          if (o2 = n2.done ? s : l, p2.arg === y)
            continue;
          return {
            value: p2.arg,
            done: n2.done
          };
        }
        "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
      }
    };
  }
  function maybeInvokeDelegate(e2, r2) {
    var n2 = r2.method, o2 = e2.iterator[n2];
    if (o2 === t)
      return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
    var i2 = tryCatch(o2, e2.iterator, r2.arg);
    if ("throw" === i2.type)
      return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
    var a2 = i2.arg;
    return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
  }
  function pushTryEntry(t2) {
    var e2 = {
      tryLoc: t2[0]
    };
    1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
  }
  function resetTryEntry(t2) {
    var e2 = t2.completion || {};
    e2.type = "normal", delete e2.arg, t2.completion = e2;
  }
  function Context(t2) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t2.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(e2) {
    if (e2 || "" === e2) {
      var r2 = e2[a];
      if (r2)
        return r2.call(e2);
      if ("function" == typeof e2.next)
        return e2;
      if (!isNaN(e2.length)) {
        var o2 = -1, i2 = function next() {
          for (; ++o2 < e2.length; )
            if (n.call(e2, o2))
              return next.value = e2[o2], next.done = false, next;
          return next.value = t, next.done = true, next;
        };
        return i2.next = i2;
      }
    }
    throw new TypeError(typeof e2 + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
    var e2 = "function" == typeof t2 && t2.constructor;
    return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
  }, e.mark = function(t2) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
  }, e.awrap = function(t2) {
    return {
      __await: t2
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
    void 0 === i2 && (i2 = Promise);
    var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
    return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
      return t3.done ? t3.value : a2.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
    return this;
  }), define(g, "toString", function() {
    return "[object Generator]";
  }), e.keys = function(t2) {
    var e2 = Object(t2), r2 = [];
    for (var n2 in e2)
      r2.push(n2);
    return r2.reverse(), function next() {
      for (; r2.length; ) {
        var t3 = r2.pop();
        if (t3 in e2)
          return next.value = t3, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function(e2) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2)
        for (var r2 in this)
          "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
    },
    stop: function() {
      this.done = true;
      var t2 = this.tryEntries[0].completion;
      if ("throw" === t2.type)
        throw t2.arg;
      return this.rval;
    },
    dispatchException: function(e2) {
      if (this.done)
        throw e2;
      var r2 = this;
      function handle(n2, o3) {
        return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
      }
      for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
        var i2 = this.tryEntries[o2], a2 = i2.completion;
        if ("root" === i2.tryLoc)
          return handle("end");
        if (i2.tryLoc <= this.prev) {
          var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
          if (c2 && u2) {
            if (this.prev < i2.catchLoc)
              return handle(i2.catchLoc, true);
            if (this.prev < i2.finallyLoc)
              return handle(i2.finallyLoc);
          } else if (c2) {
            if (this.prev < i2.catchLoc)
              return handle(i2.catchLoc, true);
          } else {
            if (!u2)
              throw new Error("try statement without catch or finally");
            if (this.prev < i2.finallyLoc)
              return handle(i2.finallyLoc);
          }
        }
      }
    },
    abrupt: function(t2, e2) {
      for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
        var o2 = this.tryEntries[r2];
        if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
          var i2 = o2;
          break;
        }
      }
      i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
      var a2 = i2 ? i2.completion : {};
      return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
    },
    complete: function(t2, e2) {
      if ("throw" === t2.type)
        throw t2.arg;
      return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
    },
    finish: function(t2) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.finallyLoc === t2)
          return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
      }
    },
    catch: function(t2) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.tryLoc === t2) {
          var n2 = r2.completion;
          if ("throw" === n2.type) {
            var o2 = n2.arg;
            resetTryEntry(r2);
          }
          return o2;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(e2, r2, n2) {
      return this.delegate = {
        iterator: values(e2),
        resultName: r2,
        nextLoc: n2
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var DEFAULT_TEXTURE_MANAGER_OPTIONS = {
  size: {
    mode: "max",
    value: 512
  },
  objectFit: "cover",
  correctCentering: false,
  maxTextureSize: 4096,
  debounceTimeout: 500,
  crossOrigin: "anonymous"
};
var MARGIN_IN_TEXTURE = 1;
function loadRasterImage(imageSource) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, crossOrigin = _ref.crossOrigin;
  return new Promise(function(resolve, reject) {
    var image = new Image();
    image.addEventListener("load", function() {
      resolve(image);
    }, {
      once: true
    });
    image.addEventListener("error", function(e) {
      reject(e.error);
    }, {
      once: true
    });
    if (crossOrigin) {
      image.setAttribute("crossOrigin", crossOrigin);
    }
    image.src = imageSource;
  });
}
function loadSVGImage(_x) {
  return _loadSVGImage.apply(this, arguments);
}
function _loadSVGImage() {
  _loadSVGImage = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(imageSource) {
    var _ref2, size, crossOrigin, resp, svgString, svg, root, originalWidth, originalHeight, correctedSvgString, blob, url, res, _args2 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref2 = _args2.length > 1 && _args2[1] !== void 0 ? _args2[1] : {}, size = _ref2.size, crossOrigin = _ref2.crossOrigin;
            if (!(crossOrigin === "use-credentials")) {
              _context2.next = 7;
              break;
            }
            _context2.next = 4;
            return fetch(imageSource, {
              credentials: "include"
            });
          case 4:
            resp = _context2.sent;
            _context2.next = 10;
            break;
          case 7:
            _context2.next = 9;
            return fetch(imageSource);
          case 9:
            resp = _context2.sent;
          case 10:
            _context2.next = 12;
            return resp.text();
          case 12:
            svgString = _context2.sent;
            svg = new DOMParser().parseFromString(svgString, "image/svg+xml");
            root = svg.documentElement;
            originalWidth = root.getAttribute("width");
            originalHeight = root.getAttribute("height");
            if (!(!originalWidth || !originalHeight)) {
              _context2.next = 19;
              break;
            }
            throw new Error("loadSVGImage: cannot use `size` if target SVG has no definite dimensions.");
          case 19:
            if (typeof size === "number") {
              root.setAttribute("width", "" + size);
              root.setAttribute("height", "" + size);
            }
            correctedSvgString = new XMLSerializer().serializeToString(svg);
            blob = new Blob([correctedSvgString], {
              type: "image/svg+xml"
            });
            url = URL.createObjectURL(blob);
            res = loadRasterImage(url);
            res["finally"](function() {
              return URL.revokeObjectURL(url);
            });
            return _context2.abrupt("return", res);
          case 26:
          case "end":
            return _context2.stop();
        }
    }, _callee2);
  }));
  return _loadSVGImage.apply(this, arguments);
}
function loadImage(_x2) {
  return _loadImage.apply(this, arguments);
}
function _loadImage() {
  _loadImage = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(imageSource) {
    var _imageSource$split$0$;
    var _ref3, size, crossOrigin, isSVG, image, _args3 = arguments;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1)
        switch (_context3.prev = _context3.next) {
          case 0:
            _ref3 = _args3.length > 1 && _args3[1] !== void 0 ? _args3[1] : {}, size = _ref3.size, crossOrigin = _ref3.crossOrigin;
            isSVG = ((_imageSource$split$0$ = imageSource.split(/[#?]/)[0].split(".").pop()) === null || _imageSource$split$0$ === void 0 ? void 0 : _imageSource$split$0$.trim().toLowerCase()) === "svg";
            if (!(isSVG && size)) {
              _context3.next = 16;
              break;
            }
            _context3.prev = 3;
            _context3.next = 6;
            return loadSVGImage(imageSource, {
              size,
              crossOrigin
            });
          case 6:
            image = _context3.sent;
            _context3.next = 14;
            break;
          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](3);
            _context3.next = 13;
            return loadRasterImage(imageSource, {
              crossOrigin
            });
          case 13:
            image = _context3.sent;
          case 14:
            _context3.next = 19;
            break;
          case 16:
            _context3.next = 18;
            return loadRasterImage(imageSource, {
              crossOrigin
            });
          case 18:
            image = _context3.sent;
          case 19:
            return _context3.abrupt("return", image);
          case 20:
          case "end":
            return _context3.stop();
        }
    }, _callee3, null, [[3, 9]]);
  }));
  return _loadImage.apply(this, arguments);
}
function refineImage(image, corrector, _ref4) {
  var objectFit = _ref4.objectFit, size = _ref4.size, correctCentering = _ref4.correctCentering;
  var sourceSize = objectFit === "contain" ? Math.max(image.width, image.height) : Math.min(image.width, image.height);
  var destinationSize = size.mode === "auto" ? sourceSize : size.mode === "force" ? size.value : Math.min(size.value, sourceSize);
  var sourceX = (image.width - sourceSize) / 2;
  var sourceY = (image.height - sourceSize) / 2;
  if (correctCentering) {
    var correction = corrector.getCorrectionOffset(image, sourceSize);
    sourceX = correction.x;
    sourceY = correction.y;
  }
  return {
    sourceX,
    sourceY,
    sourceSize,
    destinationSize
  };
}
function drawTexture(images, ctx, cursor) {
  var _ctx$canvas = ctx.canvas, width = _ctx$canvas.width, height = _ctx$canvas.height;
  var refinedImagesArray = [];
  var x = cursor.x, y = cursor.y, rowHeight = cursor.rowHeight, maxRowWidth = cursor.maxRowWidth;
  var atlas = {};
  for (var i = 0, l = images.length; i < l; i++) {
    var _images$i = images[i], key = _images$i.key, image = _images$i.image, sourceSize = _images$i.sourceSize, sourceX = _images$i.sourceX, sourceY = _images$i.sourceY, destinationSize = _images$i.destinationSize;
    var destinationSizeWithMargin = destinationSize + MARGIN_IN_TEXTURE;
    if (y + destinationSizeWithMargin > height || x + destinationSizeWithMargin > width && y + destinationSizeWithMargin + rowHeight > height) {
      continue;
    }
    if (x + destinationSizeWithMargin > width) {
      maxRowWidth = Math.max(maxRowWidth, x);
      x = 0;
      y += rowHeight;
      rowHeight = destinationSizeWithMargin;
    }
    refinedImagesArray.push({
      key,
      image,
      sourceX,
      sourceY,
      sourceSize,
      destinationX: x,
      destinationY: y,
      destinationSize
    });
    atlas[key] = {
      x,
      y,
      size: destinationSize
    };
    x += destinationSizeWithMargin;
    rowHeight = Math.max(rowHeight, destinationSizeWithMargin);
  }
  maxRowWidth = Math.max(maxRowWidth, x);
  var effectiveWidth = maxRowWidth;
  var effectiveHeight = y + rowHeight;
  for (var _i = 0, _l = refinedImagesArray.length; _i < _l; _i++) {
    var _refinedImagesArray$_ = refinedImagesArray[_i], _image = _refinedImagesArray$_.image, _sourceSize = _refinedImagesArray$_.sourceSize, _sourceX = _refinedImagesArray$_.sourceX, _sourceY = _refinedImagesArray$_.sourceY, _destinationSize = _refinedImagesArray$_.destinationSize, destinationX = _refinedImagesArray$_.destinationX, destinationY = _refinedImagesArray$_.destinationY;
    ctx.drawImage(_image, _sourceX, _sourceY, _sourceSize, _sourceSize, destinationX, destinationY, _destinationSize, _destinationSize);
  }
  return {
    atlas,
    texture: ctx.getImageData(0, 0, effectiveWidth, effectiveHeight),
    cursor: {
      x,
      y,
      rowHeight,
      maxRowWidth
    }
  };
}
function drawTextures(_ref5, images, ctx) {
  var prevAtlas = _ref5.atlas, prevTextures = _ref5.textures, prevCursor = _ref5.cursor;
  var res = {
    atlas: _objectSpread2({}, prevAtlas),
    textures: _toConsumableArray(prevTextures.slice(0, -1)),
    cursor: _objectSpread2({}, prevCursor)
  };
  var imagesToDraw = [];
  for (var key in images) {
    var _prevAtlas$key;
    var imageState = images[key];
    if (imageState.status !== "ready")
      continue;
    var textureIndex = (_prevAtlas$key = prevAtlas[key]) === null || _prevAtlas$key === void 0 ? void 0 : _prevAtlas$key.textureIndex;
    if (typeof textureIndex === "number")
      continue;
    imagesToDraw.push(_objectSpread2({
      key
    }, imageState));
  }
  var _loop = function _loop2() {
    var _drawTexture = drawTexture(imagesToDraw, ctx, res.cursor), atlas = _drawTexture.atlas, texture = _drawTexture.texture, cursor = _drawTexture.cursor;
    res.cursor = cursor;
    var remainingImages = [];
    imagesToDraw.forEach(function(image) {
      if (atlas[image.key]) {
        res.atlas[image.key] = _objectSpread2(_objectSpread2({}, atlas[image.key]), {}, {
          textureIndex: res.textures.length
        });
      } else {
        remainingImages.push(image);
      }
    });
    res.textures.push(texture);
    imagesToDraw = remainingImages;
    if (imagesToDraw.length) {
      res.cursor = {
        x: 0,
        y: 0,
        rowHeight: 0,
        maxRowWidth: 0
      };
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
  };
  while (imagesToDraw.length) {
    _loop();
  }
  return res;
}
var PictogramCenteringCorrector = function() {
  function PictogramCenteringCorrector2() {
    _classCallCheck2(this, PictogramCenteringCorrector2);
    this.canvas = document.createElement("canvas");
    this.context = this.canvas.getContext("2d", {
      willReadFrequently: true
    });
  }
  _createClass2(PictogramCenteringCorrector2, [{
    key: "getCorrectionOffset",
    value: function getCorrectionOffset(image, size) {
      this.canvas.width = size;
      this.canvas.height = size;
      this.context.clearRect(0, 0, size, size);
      this.context.drawImage(image, 0, 0, size, size);
      var data = this.context.getImageData(0, 0, size, size).data;
      var alpha = new Uint8ClampedArray(data.length / 4);
      for (var i = 0; i < data.length; i++) {
        alpha[i] = data[i * 4 + 3];
      }
      var sumX = 0;
      var sumY = 0;
      var total = 0;
      for (var y = 0; y < size; y++) {
        for (var x = 0; x < size; x++) {
          var a = alpha[y * size + x];
          total += a;
          sumX += a * x;
          sumY += a * y;
        }
      }
      var barycenterX = sumX / total;
      var barycenterY = sumY / total;
      return {
        x: barycenterX - size / 2,
        y: barycenterY - size / 2
      };
    }
  }]);
  return PictogramCenteringCorrector2;
}();
var TextureManager = function(_EventEmitter) {
  _inherits2(TextureManager2, _EventEmitter);
  function TextureManager2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck2(this, TextureManager2);
    _this = _callSuper2(this, TextureManager2);
    _defineProperty(_assertThisInitialized(_this), "canvas", document.createElement("canvas"));
    _defineProperty(_assertThisInitialized(_this), "ctx", _this.canvas.getContext("2d", {
      willReadFrequently: true
    }));
    _defineProperty(_assertThisInitialized(_this), "corrector", new PictogramCenteringCorrector());
    _defineProperty(_assertThisInitialized(_this), "imageStates", {});
    _defineProperty(_assertThisInitialized(_this), "textures", [_this.ctx.getImageData(0, 0, 1, 1)]);
    _defineProperty(_assertThisInitialized(_this), "lastTextureCursor", {
      x: 0,
      y: 0,
      rowHeight: 0,
      maxRowWidth: 0
    });
    _defineProperty(_assertThisInitialized(_this), "atlas", {});
    _this.options = _objectSpread2(_objectSpread2({}, DEFAULT_TEXTURE_MANAGER_OPTIONS), options);
    _this.canvas.width = _this.options.maxTextureSize;
    _this.canvas.height = _this.options.maxTextureSize;
    return _this;
  }
  _createClass2(TextureManager2, [{
    key: "scheduleGenerateTexture",
    value: function scheduleGenerateTexture() {
      var _this2 = this;
      if (typeof this.frameId === "number")
        return;
      if (typeof this.options.debounceTimeout === "number") {
        this.frameId = window.setTimeout(function() {
          _this2.generateTextures();
          _this2.frameId = void 0;
        }, this.options.debounceTimeout);
      } else {
        this.generateTextures();
      }
    }
  }, {
    key: "generateTextures",
    value: function generateTextures() {
      var _drawTextures = drawTextures({
        atlas: this.atlas,
        textures: this.textures,
        cursor: this.lastTextureCursor
      }, this.imageStates, this.ctx), atlas = _drawTextures.atlas, textures = _drawTextures.textures, cursor = _drawTextures.cursor;
      this.atlas = atlas;
      this.textures = textures;
      this.lastTextureCursor = cursor;
      this.emit(TextureManager2.NEW_TEXTURE_EVENT, {
        atlas,
        textures
      });
    }
    // PUBLIC API:
  }, {
    key: "registerImage",
    value: function() {
      var _registerImage = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(source) {
        var size, image;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.imageStates[source]) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                this.imageStates[source] = {
                  status: "loading"
                };
                _context.prev = 3;
                size = this.options.size;
                _context.next = 7;
                return loadImage(source, {
                  size: size.mode === "force" ? size.value : void 0,
                  crossOrigin: this.options.crossOrigin || void 0
                });
              case 7:
                image = _context.sent;
                this.imageStates[source] = _objectSpread2({
                  status: "ready",
                  image
                }, refineImage(image, this.corrector, this.options));
                this.scheduleGenerateTexture();
                _context.next = 15;
                break;
              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](3);
                this.imageStates[source] = {
                  status: "error"
                };
              case 15:
              case "end":
                return _context.stop();
            }
        }, _callee, this, [[3, 12]]);
      }));
      function registerImage(_x3) {
        return _registerImage.apply(this, arguments);
      }
      return registerImage;
    }()
  }, {
    key: "getAtlas",
    value: function getAtlas() {
      return this.atlas;
    }
  }, {
    key: "getTextures",
    value: function getTextures() {
      return this.textures;
    }
  }]);
  return TextureManager2;
}(import_events.EventEmitter);
_defineProperty(TextureManager, "NEW_TEXTURE_EVENT", "newTexture");
var _excluded = ["drawHover", "drawLabel", "drawingMode", "keepWithinCircle", "padding", "colorAttribute", "imageAttribute"];
var _WebGLRenderingContex2 = WebGLRenderingContext;
var UNSIGNED_BYTE2 = _WebGLRenderingContex2.UNSIGNED_BYTE;
var FLOAT2 = _WebGLRenderingContex2.FLOAT;
var DEFAULT_CREATE_NODE_IMAGE_OPTIONS = _objectSpread2(_objectSpread2({}, DEFAULT_TEXTURE_MANAGER_OPTIONS), {}, {
  drawingMode: "background",
  keepWithinCircle: true,
  drawLabel: void 0,
  drawHover: void 0,
  padding: 0,
  colorAttribute: "color",
  imageAttribute: "image"
});
var UNIFORMS2 = ["u_sizeRatio", "u_correctionRatio", "u_cameraAngle", "u_percentagePadding", "u_matrix", "u_colorizeImages", "u_keepWithinCircle", "u_atlas"];
function createNodeImageProgram(options) {
  var _NodeImageProgram;
  var gl = document.createElement("canvas").getContext("webgl");
  var defaultMaxTextureSize = Math.min(gl.getParameter(gl.MAX_TEXTURE_SIZE), DEFAULT_TEXTURE_MANAGER_OPTIONS.maxTextureSize);
  gl.canvas.remove();
  var _maxTextureSize = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_CREATE_NODE_IMAGE_OPTIONS), {
    maxTextureSize: defaultMaxTextureSize
  }), options || {}), drawHover = _maxTextureSize.drawHover, drawLabel = _maxTextureSize.drawLabel, drawingMode = _maxTextureSize.drawingMode, keepWithinCircle = _maxTextureSize.keepWithinCircle, padding = _maxTextureSize.padding, colorAttribute = _maxTextureSize.colorAttribute, imageAttribute = _maxTextureSize.imageAttribute, textureManagerOptions = _objectWithoutProperties(_maxTextureSize, _excluded);
  var textureManager = new TextureManager(textureManagerOptions);
  return _NodeImageProgram = function(_NodeProgram) {
    _inherits2(NodeImageProgram2, _NodeProgram);
    function NodeImageProgram2(gl2, pickingBuffer, renderer) {
      var _this;
      _classCallCheck2(this, NodeImageProgram2);
      _this = _callSuper2(this, NodeImageProgram2, [gl2, pickingBuffer, renderer]);
      _defineProperty(_assertThisInitialized(_this), "drawLabel", drawLabel);
      _defineProperty(_assertThisInitialized(_this), "drawHover", drawHover);
      _defineProperty(_assertThisInitialized(_this), "textureManagerCallback", null);
      _this.textureManagerCallback = function(_ref) {
        var atlas = _ref.atlas, textures = _ref.textures;
        var shouldUpgradeShaders = textures.length !== _this.textures.length;
        _this.atlas = atlas;
        _this.textureImages = textures;
        if (shouldUpgradeShaders)
          _this.upgradeShaders();
        _this.bindTextures();
        if (_this.latestRenderParams)
          _this.render(_this.latestRenderParams);
        if (_this.renderer && _this.renderer.refresh)
          _this.renderer.refresh();
      };
      textureManager.on(TextureManager.NEW_TEXTURE_EVENT, _this.textureManagerCallback);
      _this.atlas = textureManager.getAtlas();
      _this.textureImages = textureManager.getTextures();
      _this.textures = _this.textureImages.map(function() {
        return gl2.createTexture();
      });
      _this.bindTextures();
      return _this;
    }
    _createClass2(NodeImageProgram2, [{
      key: "getDefinition",
      value: function getDefinition() {
        return {
          VERTICES: 3,
          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$12,
          FRAGMENT_SHADER_SOURCE: getFragmentShader({
            texturesCount: textureManager.getTextures().length
          }),
          METHOD: WebGLRenderingContext.TRIANGLES,
          UNIFORMS: UNIFORMS2,
          ATTRIBUTES: [{
            name: "a_position",
            size: 2,
            type: FLOAT2
          }, {
            name: "a_size",
            size: 1,
            type: FLOAT2
          }, {
            name: "a_color",
            size: 4,
            type: UNSIGNED_BYTE2,
            normalized: true
          }, {
            name: "a_id",
            size: 4,
            type: UNSIGNED_BYTE2,
            normalized: true
          }, {
            name: "a_texture",
            size: 4,
            type: FLOAT2
          }, {
            name: "a_textureIndex",
            size: 1,
            type: FLOAT2
          }],
          CONSTANT_ATTRIBUTES: [{
            name: "a_angle",
            size: 1,
            type: FLOAT2
          }],
          CONSTANT_DATA: [[NodeImageProgram2.ANGLE_1], [NodeImageProgram2.ANGLE_2], [NodeImageProgram2.ANGLE_3]]
        };
      }
    }, {
      key: "upgradeShaders",
      value: function upgradeShaders() {
        var def = this.getDefinition();
        var _this$normalProgram = this.normalProgram, program = _this$normalProgram.program, buffer = _this$normalProgram.buffer, vertexShader = _this$normalProgram.vertexShader, fragmentShader = _this$normalProgram.fragmentShader, gl2 = _this$normalProgram.gl;
        gl2.deleteProgram(program);
        gl2.deleteBuffer(buffer);
        gl2.deleteShader(vertexShader);
        gl2.deleteShader(fragmentShader);
        this.normalProgram = this.getProgramInfo("normal", gl2, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);
      }
    }, {
      key: "kill",
      value: function kill() {
        var _this$normalProgram2;
        var gl2 = (_this$normalProgram2 = this.normalProgram) === null || _this$normalProgram2 === void 0 ? void 0 : _this$normalProgram2.gl;
        if (gl2) {
          for (var i = 0; i < this.textures.length; i++) {
            gl2.deleteTexture(this.textures[i]);
          }
        }
        if (this.textureManagerCallback) {
          textureManager.off(TextureManager.NEW_TEXTURE_EVENT, this.textureManagerCallback);
          this.textureManagerCallback = null;
        }
        _get(_getPrototypeOf(NodeImageProgram2.prototype), "kill", this).call(this);
      }
    }, {
      key: "bindTextures",
      value: function bindTextures() {
        var gl2 = this.normalProgram.gl;
        for (var i = 0; i < this.textureImages.length; i++) {
          if (i >= this.textures.length) {
            var texture = gl2.createTexture();
            if (texture)
              this.textures.push(texture);
          }
          gl2.activeTexture(gl2.TEXTURE0 + i);
          gl2.bindTexture(gl2.TEXTURE_2D, this.textures[i]);
          gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, this.textureImages[i]);
          gl2.generateMipmap(gl2.TEXTURE_2D);
        }
      }
    }, {
      key: "renderProgram",
      value: function renderProgram(params, programInfo) {
        if (!programInfo.isPicking) {
          var _gl = programInfo.gl;
          for (var i = 0; i < this.textureImages.length; i++) {
            _gl.activeTexture(_gl.TEXTURE0 + i);
            _gl.bindTexture(_gl.TEXTURE_2D, this.textures[i]);
          }
        }
        _get(_getPrototypeOf(NodeImageProgram2.prototype), "renderProgram", this).call(this, params, programInfo);
      }
    }, {
      key: "processVisibleItem",
      value: function processVisibleItem(nodeIndex, startIndex, data) {
        var array = this.array;
        var color = floatColor(data[colorAttribute]);
        var imageSource = data[imageAttribute];
        var imagePosition = imageSource ? this.atlas[imageSource] : void 0;
        if (typeof imageSource === "string" && !imagePosition)
          textureManager.registerImage(imageSource);
        array[startIndex++] = data.x;
        array[startIndex++] = data.y;
        array[startIndex++] = data.size;
        array[startIndex++] = color;
        array[startIndex++] = nodeIndex;
        if (imagePosition && typeof imagePosition.textureIndex === "number") {
          var _this$textureImages$i = this.textureImages[imagePosition.textureIndex], width = _this$textureImages$i.width, height = _this$textureImages$i.height;
          array[startIndex++] = imagePosition.x / width;
          array[startIndex++] = imagePosition.y / height;
          array[startIndex++] = imagePosition.size / width;
          array[startIndex++] = imagePosition.size / height;
          array[startIndex++] = imagePosition.textureIndex;
        } else {
          array[startIndex++] = 0;
          array[startIndex++] = 0;
          array[startIndex++] = 0;
          array[startIndex++] = 0;
          array[startIndex++] = 0;
        }
      }
    }, {
      key: "setUniforms",
      value: function setUniforms(params, _ref2) {
        var gl2 = _ref2.gl, uniformLocations = _ref2.uniformLocations;
        var u_sizeRatio = uniformLocations.u_sizeRatio, u_correctionRatio = uniformLocations.u_correctionRatio, u_matrix = uniformLocations.u_matrix, u_atlas = uniformLocations.u_atlas, u_colorizeImages = uniformLocations.u_colorizeImages, u_keepWithinCircle = uniformLocations.u_keepWithinCircle, u_cameraAngle = uniformLocations.u_cameraAngle, u_percentagePadding = uniformLocations.u_percentagePadding;
        this.latestRenderParams = params;
        gl2.uniform1f(u_correctionRatio, params.correctionRatio);
        gl2.uniform1f(u_sizeRatio, keepWithinCircle ? params.sizeRatio : params.sizeRatio / Math.SQRT2);
        gl2.uniform1f(u_cameraAngle, params.cameraAngle);
        gl2.uniform1f(u_percentagePadding, padding);
        gl2.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl2.uniform1iv(u_atlas, _toConsumableArray(new Array(this.textureImages.length)).map(function(_, i) {
          return i;
        }));
        gl2.uniform1i(u_colorizeImages, drawingMode === "color" ? 1 : 0);
        gl2.uniform1i(u_keepWithinCircle, keepWithinCircle ? 1 : 0);
      }
    }]);
    return NodeImageProgram2;
  }(NodeProgram), _defineProperty(_NodeImageProgram, "ANGLE_1", 0), _defineProperty(_NodeImageProgram, "ANGLE_2", 2 * Math.PI / 3), _defineProperty(_NodeImageProgram, "ANGLE_3", 4 * Math.PI / 3), _defineProperty(_NodeImageProgram, "textureManager", textureManager), _NodeImageProgram;
}
var NodeImageProgram = createNodeImageProgram();
var NodePictogramProgram = createNodeImageProgram({
  keepWithinCircle: false,
  size: {
    mode: "force",
    value: 256
  },
  drawingMode: "color",
  correctCentering: true
});
export {
  NodeImageProgram,
  NodePictogramProgram,
  createNodeImageProgram
};
//# sourceMappingURL=@sigma_node-image.js.map
